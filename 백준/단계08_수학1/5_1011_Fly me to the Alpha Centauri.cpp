///*

#include <iostream>
using namespace std;

int main(int argc, char* argv[]) {
	// 2019-04-10-수
	// Step8 - 수학1
	// 5	1011	Fly me to the Alpha Centauri
	// https://www.acmicpc.net/problem/1011

	// 알고리즘 구상 - 기본 규칙
	// x와 y사이의 거리를 d라고 할 때,
	// 1. d가 n의 제곱과 (n+1)의 제곱 사이에 들어있다고 가정한다. [n^2<=d<(n+1)^2]
	// 2. 이때 n의 값을 구한다.
	// 3. 최소이동 횟수 w는,
	//  d에서 n^2값을 뺀 값이,
	//  3.1. 0으로 딱 떨어질 때는 2n - 1이고, 
	//  3.2. n 이하일 때는 2n이고,
	//  3.3. n 초과일 때는 2n+1이다.
	// 4. 결과물을 출력한다.

	// 슈방 틀렸었다... 결과는 시간초과...
	// https://www.acmicpc.net/board/view/26059 에 따르면,
	// 입력이 int범위라고 해서 중간 계산 과정이 int를 안 넘는다는 보장은 없다고 한다.
	// 나같은 경우, 0 2147483647를 구하는데 시간초과가 나버렸다.
	// 보아하니 d값을 구하고, d < (n+1)*2를 만족하는 n값을 구해야 하는데, 
	// 여기서 (n+1)*(n*1)의 값이 int형을 초과해버린다. 그래서 버퍼오버플로우가 나고 못구해서 시간초과가 났던것 같다.
	// long 형으로 모두 바꾸니까 통과했다.

	// 문제점을 파악하고 보니, 여기서 굳이 모두 long으로 바꿀 필요는 없고, 
	// 'd'값만 long형으로 바꿔도 될것 같다.
	// 아놔.. 안되내... 왜지??? 아 그냥 long으로 모두 바꿔야겠다.
	// 음... 보아하니 C++은 int와 long 모두 2^31-1까지 다룰수 있다.
	// 이전 운영체제 버전에 따라, 컴파일러에 따라 다를수도 있다지만 요즘은 큰 차이가 없다는 모양이다.
	// 그래서 내가 자바에서 생각하는 것처럼 long형을 쓰려면 long long 형을 써줘야 한다.

	// 보니 d값도 결국는 int 범위 내이고, n*n의 값이 int범위를 초과하는 것이므로 n만 long long으로 바꿔주니 잘 동작했다.


	// 코딩
	int T;
	cin >> T;

	for (long i = 0; i < T; i++) {
		// x와 y사이의 거리를 d라고 할 때,
		int x, y;
		int d;
		cin >> x >> y;
		d = y - x; // x는 항상 y보다 작은 값을 갖는다. ( 0 ≤ x < y < 2^31)

				   // 1. d가 n의 제곱과 (n+1)의 제곱 사이에 들어있다고 가정한다. [n^2<=d<(n+1)^2]
				   // 2. 이때 n의 값을 구한다.
		long long n = 0;
		while (d >= (n + 1) * (n + 1)) {  //주의!. 여기서 d의 값이 2^31일경우, long형이여야만 제대로 구할 수가 있다.
			n++;
		}

		// 3. 최소이동 횟수 w는,
		int w;
		//  d에서 n^2값을 뺀 값이,
		int d2 = d - (n * n);
		//  3.1. 0으로 딱 떨어질 때는 2n - 1이고, 
		if (d2 == 0) {
			w = 2 * n - 1;
		}
		//  3.2. n 이하일 때는 2n이고,
		else if (d2 <= n) {
			w = 2 * n;
		}
		//  3.3. n 초과일 때는 2n+1이다.
		else {
			w = 2 * n + 1;
		}

		// 4. 결과물을 출력한다.
		cout << w << endl;
	}

	return 0;
}